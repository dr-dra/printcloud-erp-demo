import logging

from django.db import transaction
from rest_framework import serializers
from decimal import Decimal

from apps.costing.models import CostingEstimating, CostingSheet
from apps.customers.serializers import CustomerListSerializer, CustomerSerializer
from apps.employees.models import Employee
from apps.sales.models import FinishedProduct
from apps.users.serializers import UserSerializer
from apps.core.services import CommunicationLogger
from apps.sales.invoices.models import SalesCreditNote

from .models import SalesOrder, SalesOrderItem, SalesOrderTimeline, OrderAttachment, OrderShare, OrderPayment

logger = logging.getLogger(__name__)


def build_project_name(items):
    """Build project name from first 3 unique item names."""
    if not items:
        return None

    item_names = []
    for item in items[:3]:
        name = item.get('item_name') or item.get('item')
        if name and str(name).strip():
            item_names.append(str(name).strip())

    if not item_names:
        return None

    unique_names = []
    for name in item_names:
        if name not in unique_names:
            unique_names.append(name)

    if len(unique_names) <= 2:
        return ' & '.join(unique_names)

    return ', '.join(unique_names[:2]) + ' & ' + unique_names[2]


class OrderPaymentSerializer(serializers.ModelSerializer):
    """Serializer for order payments (advances)"""

    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)
    deposit_account_name = serializers.SerializerMethodField()
    cheque_deposit_account_name = serializers.SerializerMethodField()
    voided_by_name = serializers.CharField(source='voided_by.get_full_name', read_only=True, allow_null=True)
    reversed_by_name = serializers.CharField(source='reversed_by.get_full_name', read_only=True, allow_null=True)
    refunded_by_name = serializers.CharField(source='refunded_by.get_full_name', read_only=True, allow_null=True)
    payment_method_display = serializers.CharField(source='get_payment_method_display', read_only=True)

    class Meta:
        model = OrderPayment
        fields = [
            'id', 'order', 'payment_date', 'amount', 'payment_method', 'payment_method_display',
            'reference_number', 'notes', 'created_by', 'created_by_name',
            'created_at',
            # Receipt tracking
            'receipt_number', 'receipt_generated_at',
            # Accounting integration
            'deposit_account', 'deposit_account_name',
            'journal_entry',
            # Cheque handling
            'cheque_number', 'cheque_date', 'cheque_cleared', 'cheque_cleared_date',
            'cheque_clearance_journal_entry', 'cheque_deposit_account', 'cheque_deposit_account_name',
            # Void tracking
            'is_void', 'void_reason', 'voided_by', 'voided_by_name', 'voided_at',
            # Reversal tracking
            'is_reversed', 'reversed_by', 'reversed_by_name', 'reversed_at', 'reversal_journal_entry',
            # Refund tracking
            'is_refunded', 'refunded_by', 'refunded_by_name', 'refunded_at', 'refund_journal_entry',
        ]
        read_only_fields = [
            'order',  # Set by view, not by client
            'created_by',  # Set by view, not by client
            'receipt_number', 'receipt_generated_at',  # Generated by backend
            'deposit_account',  # Auto-mapped by backend
            'journal_entry', 'cheque_clearance_journal_entry',
            'is_void', 'voided_at', 'voided_by', 'created_at',
            'is_reversed', 'reversed_at', 'reversed_by', 'reversal_journal_entry',
            'is_refunded', 'refunded_at', 'refunded_by', 'refund_journal_entry',
        ]

    def get_deposit_account_name(self, obj):
        """Return formatted account name and code."""
        if obj.deposit_account:
            return f"{obj.deposit_account.account_code} - {obj.deposit_account.account_name}"
        return None

    def get_cheque_deposit_account_name(self, obj):
        """Return formatted cheque deposit account name."""
        if obj.cheque_deposit_account:
            return f"{obj.cheque_deposit_account.account_code} - {obj.cheque_deposit_account.account_name}"
        return None

    def validate(self, data):
        """Validate payment method specific required fields."""
        payment_method = data.get('payment_method')

        # For bank_transfer and card: reference_number is required
        if payment_method in ['bank_transfer', 'card']:
            if not data.get('reference_number'):
                raise serializers.ValidationError({
                    'reference_number': f'{payment_method.replace("_", " ").title()} requires a reference number'
                })

        # For cheque: cheque_number is required
        if payment_method == 'cheque':
            if not data.get('cheque_number'):
                raise serializers.ValidationError({
                    'cheque_number': 'Cheque number is required for cheque payments'
                })

        return data


class SalesOrderTimelineSerializer(serializers.ModelSerializer):
    """Serializer for order timeline entries"""

    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)
    event_type_display = serializers.CharField(source='get_event_type_display', read_only=True)

    class Meta:
        model = SalesOrderTimeline
        fields = [
            'id', 'event_type', 'event_type_display', 'message',
            'old_status', 'new_status', 'created_at', 'created_by', 'created_by_name'
        ]
        read_only_fields = ['id', 'created_at', 'created_by']


class OrderAttachmentSerializer(serializers.ModelSerializer):
    """Serializer for order file attachments"""

    uploaded_by_name = serializers.CharField(source='uploaded_by.get_full_name', read_only=True)
    file_url = serializers.SerializerMethodField()
    file_type_display = serializers.CharField(source='get_file_type_display', read_only=True)

    class Meta:
        model = OrderAttachment
        fields = [
            'id', 'title', 'description', 'file_type', 'file_type_display',
            'file', 'file_url', 'uploaded_by', 'uploaded_by_name', 'uploaded_at'
        ]
        read_only_fields = ['id', 'uploaded_at']

    def get_file_url(self, obj):
        if obj.file:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(obj.file.url)
        return None


class SalesOrderItemSerializer(serializers.ModelSerializer):
    """Serializer for order items"""

    costing_sheet_name = serializers.CharField(source='costing_sheet.name', read_only=True, allow_null=True)
    costing_estimating_id = serializers.SerializerMethodField()
    finished_product_name = serializers.CharField(source='finished_product.name', read_only=True, allow_null=True)
    finished_product_category = serializers.CharField(source='finished_product.category.category_name', read_only=True, allow_null=True)
    finished_product_dimensions = serializers.SerializerMethodField()
    item_status_display = serializers.CharField(source='get_item_status_display', read_only=True)

    # Allow both ForeignKey objects and _id integer values to be passed
    costing_sheet_id = serializers.IntegerField(required=False, allow_null=True, write_only=True)
    finished_product_id = serializers.IntegerField(required=False, allow_null=True, write_only=True)

    class Meta:
        model = SalesOrderItem
        fields = [
            'id', 'item_name', 'description', 'quantity', 'unit_price', 'amount',
            'finished_product', 'finished_product_id', 'finished_product_name',
            'finished_product_category', 'finished_product_dimensions',
            'costing_sheet', 'costing_sheet_id', 'costing_sheet_name', 'costing_estimating_id',
            'cs_profit_margin', 'cs_profit', 'cs_total',
            'job_ticket_generated', 'job_ticket_number', 'production_notes',
            'item_status', 'item_status_display'
        ]

    def get_costing_estimating_id(self, obj):
        """Get the parent CostingEstimating ID for the URL"""
        if obj.costing_sheet:
            estimating = CostingEstimating.objects.filter(costingId=obj.costing_sheet.costingId).first()
            if estimating:
                return estimating.id
        return None

    def get_finished_product_dimensions(self, obj):
        """Get formatted dimensions display from finished product"""
        if obj.finished_product and obj.finished_product.width and obj.finished_product.height:
            width = int(obj.finished_product.width) if obj.finished_product.width == int(obj.finished_product.width) else obj.finished_product.width
            height = int(obj.finished_product.height) if obj.finished_product.height == int(obj.finished_product.height) else obj.finished_product.height
            return f"{width}mm x {height}mm"
        return ""

    def create(self, validated_data):
        # Handle _id fields explicitly if provided
        costing_sheet_id = validated_data.pop('costing_sheet_id', None)
        finished_product_id = validated_data.pop('finished_product_id', None)

        if costing_sheet_id:
            validated_data['costing_sheet_id'] = costing_sheet_id
        if finished_product_id:
            validated_data['finished_product_id'] = finished_product_id

        return super().create(validated_data)


class SalesOrderListSerializer(serializers.ModelSerializer):
    """Serializer for order list view - minimal fields for performance"""

    customer_name = serializers.CharField(source='customer.name', read_only=True)
    customer_id = serializers.IntegerField(source='customer.id', read_only=True)
    item_count = serializers.SerializerMethodField()
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    number_type_display = serializers.CharField(source='get_number_type_display', read_only=True)
    created_by_name = serializers.SerializerMethodField()
    quotation_number = serializers.CharField(source='quotation.quot_number', read_only=True)
    costing_number = serializers.SerializerMethodField()

    class Meta:
        model = SalesOrder
        fields = [
            'id', 'order_number', 'number_type', 'number_type_display',
            'customer_id', 'customer_name', 'quotation_number', 'costing_number',
            'order_date', 'required_date', 'delivered_date',
            'status', 'status_display', 'production_stage', 'po_so_number', 'project_name',
            'net_total', 'vat_rate', 'vat_amount', 'amount_paid', 'balance_due',
            'is_active', 'created_by_name',
            'created_date', 'item_count'
        ]

    def get_item_count(self, obj):
        """Get the number of items in this order"""
        return obj.items.count()

    def get_costing_number(self, obj):
        """Get the costing number if order was created from costing"""
        if obj.costing_id:
            return str(obj.costing_id)
        return None

    def get_created_by_name(self, obj):
        """Get prepared by name from prepared_by_legacy_id field (same approach as costing module)"""
        # Priority 1: Try to get from legacy ID (for migrated orders)
        if obj.prepared_by_legacy_id:
            try:
                employee = Employee.objects.filter(legacy_id=obj.prepared_by_legacy_id).first()
                if employee:
                    # Return only the first name (same as costing module)
                    first_name = employee.full_name.split()[0] if employee.full_name else "Unknown"
                    return first_name
                return f"User {obj.prepared_by_legacy_id}"
            except Exception:
                return f"User {obj.prepared_by_legacy_id}"

        # Priority 2: Standard fields (for new orders created in the new system)
        if obj.prepared_by:
            full_name = obj.prepared_by.get_full_name()
            return full_name.split()[0] if full_name else "Unknown"
        if obj.created_by:
            full_name = obj.created_by.get_full_name()
            return full_name.split()[0] if full_name else "Unknown"
        return "Unknown"


class SalesOrderDetailSerializer(serializers.ModelSerializer):
    """Serializer for order detail view - full data"""

    class CreditNoteListSerializer(serializers.ModelSerializer):
        class Meta:
            model = SalesCreditNote
            fields = [
                'id',
                'credit_note_number',
                'credit_note_type',
                'credit_note_date',
                'status',
                'amount',
                'reason',
                'detail_note',
                'description',
                'invoice',
                'order',
                'invoice_payment',
                'order_payment',
                'payout_method',
                'payout_voucher_number',
                'payout_cheque_number',
                'created_at',
            ]

    customer = CustomerSerializer(read_only=True)
    items = SalesOrderItemSerializer(many=True, read_only=True)
    payments = OrderPaymentSerializer(many=True, read_only=True)
    credit_notes = CreditNoteListSerializer(many=True, read_only=True)
    timeline = SalesOrderTimelineSerializer(source='timeline_entries', many=True, read_only=True)
    attachments = OrderAttachmentSerializer(many=True, read_only=True)
    created_by = UserSerializer(read_only=True)
    updated_by = UserSerializer(read_only=True)
    prepared_by = UserSerializer(read_only=True)
    costing_name = serializers.CharField(source='costing.name', read_only=True)
    costing_number = serializers.SerializerMethodField()
    quotation_number = serializers.CharField(source='quotation.quot_number', read_only=True)
    quotation_id = serializers.IntegerField(source='quotation.id', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    communication_count = serializers.SerializerMethodField()

    class Meta:
        model = SalesOrder
        fields = [
            'id', 'order_number', 'number_type', 'customer',
            'quotation', 'quotation_id', 'quotation_number',
            'order_date', 'required_date', 'production_start_date',
            'completion_date', 'delivered_date',
            'status', 'status_display', 'production_stage', 'po_so_number', 'project_name',
            'notes', 'customer_notes', 'delivery_instructions',
            'subtotal', 'discount', 'delivery_charge', 'vat_rate', 'vat_amount', 'net_total',
            'amount_paid', 'balance_due',
            'costing', 'costing_name', 'costing_number',
            'prepared_by', 'prepared_from', 'prepared_reff',
            'is_active', 'created_by', 'created_date',
            'updated_by', 'updated_date',
            'items', 'payments', 'credit_notes', 'timeline', 'attachments', 'communication_count'
        ]
        read_only_fields = [
            'id', 'created_by', 'created_date', 'updated_by', 'updated_date',
            'timeline', 'communication_count', 'amount_paid', 'balance_due'
        ]

    def get_costing_number(self, obj):
        """Get the costing number if order was created from costing"""
        if obj.costing_id:
            return str(obj.costing_id)
        return None

    def get_communication_count(self, obj):
        """Get counts of different communication types from DocumentCommunicationLog"""
        try:
            return {
                'email': CommunicationLogger.get_communication_count('order', obj.id, 'email'),
                'whatsapp': CommunicationLogger.get_communication_count('order', obj.id, 'whatsapp'),
                'print': CommunicationLogger.get_communication_count('order', obj.id, 'print'),
            }
        except Exception as e:
            logger.warning(f"Failed to get communication count for order {obj.id}: {e}")
            return {'email': 0, 'whatsapp': 0, 'print': 0}


class SalesOrderCreateSerializer(serializers.ModelSerializer):
    """Serializer for creating/updating orders"""

    items = SalesOrderItemSerializer(many=True, required=False)
    costing_sheet_ids = serializers.ListField(
        child=serializers.IntegerField(),
        required=False,
        write_only=True
    )

    class Meta:
        model = SalesOrder
        fields = [
            'id', 'order_number', 'number_type', 'customer', 'quotation',
            'order_date', 'required_date', 'status', 'production_stage', 'po_so_number',
            'notes', 'customer_notes', 'delivery_instructions',
            'subtotal', 'discount', 'delivery_charge', 'vat_rate', 'vat_amount', 'net_total',
            'costing', 'prepared_from', 'prepared_reff',
            'project_name', 'items', 'costing_sheet_ids'
        ]
        read_only_fields = ['id']

    def create(self, validated_data):
        items_data = validated_data.pop('items', [])
        costing_sheet_ids = validated_data.pop('costing_sheet_ids', [])

        with transaction.atomic():
            # Set created_by and prepared_by from request user
            user = self.context.get('request').user if self.context.get('request') else None
            validated_data['created_by'] = user
            if not validated_data.get('prepared_by'):
                validated_data['prepared_by'] = user

            # Initialize payment tracking on creation
            validated_data.setdefault('amount_paid', Decimal('0.00'))
            if validated_data.get('balance_due') is None:
                validated_data['balance_due'] = validated_data.get('net_total', Decimal('0.00'))

            project_name = build_project_name(items_data)
            if project_name:
                validated_data['project_name'] = project_name

            order = SalesOrder.objects.create(**validated_data)

            # Track costing sheets to lock (from both direct IDs and items)
            costing_sheets_to_lock = set(costing_sheet_ids) if costing_sheet_ids else set()

            # Create items if provided
            for item_data in items_data:
                # Auto-link FinishedProduct if item name matches
                finished_product = None
                item_name = item_data.get('item_name', '')

                if item_name:
                    try:
                        # Try to find FinishedProduct by exact name match
                        finished_product = FinishedProduct.objects.filter(
                            name__iexact=item_name,
                            is_active=True
                        ).first()

                        if finished_product:
                            item_data['finished_product'] = finished_product
                            # Enhance description with FinishedProduct details if available
                            if finished_product.description and not item_data.get('description'):
                                item_data['description'] = finished_product.description
                            elif finished_product.description and item_data.get('description'):
                                # Append FinishedProduct description to existing description
                                item_data['description'] = f"{item_data['description']}\n{finished_product.description}"

                    except Exception as e:
                        # Log the error but don't fail the creation
                        logger.warning(f"Failed to auto-link FinishedProduct for item '{item_name}': {e}")

                SalesOrderItem.objects.create(order=order, **item_data)

                # Collect costing sheet IDs from items
                if item_data.get('costing_sheet_id'):
                    costing_sheets_to_lock.add(item_data['costing_sheet_id'])

            # Lock costing sheets that were used in this order
            if costing_sheets_to_lock:
                try:
                    CostingSheet.objects.filter(id__in=costing_sheets_to_lock).update(is_locked=1)
                    logger.info(f"Locked {len(costing_sheets_to_lock)} costing sheets for order {order.order_number}")
                except Exception as e:
                    logger.warning(f"Failed to lock costing sheets for order {order.order_number}: {e}")

            # Create initial timeline entry
            if order.quotation:
                message = f"Order created from Quotation {order.quotation.quot_number}"
            elif order.prepared_from == 'quotation' and order.prepared_reff:
                message = f"Order created from Quotation {order.prepared_reff}"
            elif order.prepared_from == 'costing' and order.costing_id:
                message = f"Order created from Costing #{order.costing_id}"
            elif order.prepared_from == 'costing' and order.prepared_reff:
                message = f"Order created from {order.prepared_reff}"
            else:
                message = "Order created"

            SalesOrderTimeline.objects.create(
                order=order,
                event_type='created',
                message=message,
                created_by=user
            )

        return order

    def update(self, instance, validated_data):
        items_data = validated_data.pop('items', [])

        with transaction.atomic():
            # Set updated_by from request user
            user = self.context.get('request').user if self.context.get('request') else None
            validated_data['updated_by'] = user

            project_name = build_project_name(items_data) if items_data else instance.project_name
            if project_name:
                validated_data['project_name'] = project_name

            # Update order fields
            for attr, value in validated_data.items():
                setattr(instance, attr, value)
            instance.save()

            # Delete existing items and create new ones
            instance.items.all().delete()
            for item_data in items_data:
                SalesOrderItem.objects.create(order=instance, **item_data)

            # Create timeline entry for update
            SalesOrderTimeline.objects.create(
                order=instance,
                event_type='modified',
                message=f"Order updated via API",
                created_by=user
            )

        return instance

    def validate(self, attrs):
        items_data = self.initial_data.get('items', [])
        vat_rate_value = attrs.get('vat_rate', None)
        if vat_rate_value is None:
            vat_rate_value = Decimal(str(self.initial_data.get('vat_rate', '0')))

        has_exempt = False
        has_taxable = False
        has_unknown = False

        for item_data in items_data:
            finished_product = item_data.get('finished_product')
            finished_product_id = item_data.get('finished_product_id')

            if finished_product is None and finished_product_id:
                finished_product = FinishedProduct.objects.filter(
                    id=finished_product_id,
                    is_active=True
                ).first()

            if finished_product is None and item_data.get('item_name'):
                finished_product = FinishedProduct.objects.filter(
                    name__iexact=item_data.get('item_name'),
                    is_active=True
                ).first()

            if finished_product is None:
                has_unknown = True
                continue

            if finished_product.is_vat_exempt:
                has_exempt = True
            else:
                has_taxable = True

        if has_exempt and has_taxable:
            raise serializers.ValidationError({
                'items': 'Cannot mix VAT-exempt and VATable items in the same order.'
            })

        if has_exempt and Decimal(vat_rate_value) > 0:
            raise serializers.ValidationError({
                'vat_rate': 'VAT rate must be 0 for VAT-exempt orders.'
            })

        if has_taxable and Decimal(vat_rate_value) <= 0:
            raise serializers.ValidationError({
                'vat_rate': 'VAT rate must be greater than 0 for VATable orders.'
            })

        if has_unknown and (has_exempt or has_taxable):
            raise serializers.ValidationError({
                'items': 'All items must use a Finished Product to enforce VAT exemption rules.'
            })

        return attrs
