from rest_framework import serializers
from .models import SalesInvoice, SalesInvoiceItem, SalesInvoiceTimeline, InvoicePayment, SalesCreditNote
from apps.customers.serializers import CustomerSerializer
from apps.sales.orders.serializers import SalesOrderListSerializer
from apps.employees.models import Employee

class SalesInvoiceItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = SalesInvoiceItem
        fields = '__all__'

class SalesInvoiceTimelineSerializer(serializers.ModelSerializer):
    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)

    class Meta:
        model = SalesInvoiceTimeline
        fields = '__all__'

class InvoicePaymentSerializer(serializers.ModelSerializer):
    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)
    deposit_account_name = serializers.SerializerMethodField()
    cheque_deposit_account_name = serializers.SerializerMethodField()
    voided_by_name = serializers.CharField(source='voided_by.get_full_name', read_only=True, allow_null=True)
    reversed_by_name = serializers.CharField(source='reversed_by.get_full_name', read_only=True, allow_null=True)
    refunded_by_name = serializers.CharField(source='refunded_by.get_full_name', read_only=True, allow_null=True)

    class Meta:
        model = InvoicePayment
        fields = [
            'id', 'invoice', 'payment_date', 'amount', 'payment_method',
            'reference_number', 'notes', 'created_by', 'created_by_name',
            'created_at',
            # Receipt tracking
            'receipt_number', 'receipt_generated_at',
            # Accounting integration
            'deposit_account', 'deposit_account_name',
            'journal_entry',
            # Cheque handling
            'cheque_number', 'cheque_date', 'cheque_cleared', 'cheque_cleared_date',
            'cheque_clearance_journal_entry', 'cheque_deposit_account', 'cheque_deposit_account_name',
            # Void tracking
            'is_void', 'void_reason', 'voided_by', 'voided_by_name', 'voided_at',
            # Reversal tracking
            'is_reversed', 'reversed_by', 'reversed_by_name', 'reversed_at', 'reversal_journal_entry',
            # Refund tracking
            'is_refunded', 'refunded_by', 'refunded_by_name', 'refunded_at', 'refund_journal_entry'
        ]
        read_only_fields = [
            'invoice',  # Set by view, not by client
            'created_by',  # Set by view, not by client
            'receipt_number', 'receipt_generated_at',  # Generated by backend
            'deposit_account',  # Auto-mapped by backend
            'journal_entry', 'cheque_clearance_journal_entry',
            'is_void', 'voided_at', 'voided_by', 'created_at',
            'is_reversed', 'reversed_at', 'reversed_by', 'reversal_journal_entry',
            'is_refunded', 'refunded_at', 'refunded_by', 'refund_journal_entry'
        ]

    def get_deposit_account_name(self, obj):
        """Return formatted account name and code."""
        if obj.deposit_account:
            return f"{obj.deposit_account.account_code} - {obj.deposit_account.account_name}"
        return None

    def get_cheque_deposit_account_name(self, obj):
        """Return formatted cheque deposit account name."""
        if obj.cheque_deposit_account:
            return f"{obj.cheque_deposit_account.account_code} - {obj.cheque_deposit_account.account_name}"
        return None


class SalesCreditNoteSerializer(serializers.ModelSerializer):
    approved_by_name = serializers.CharField(source='approved_by.get_full_name', read_only=True)
    customer_name = serializers.CharField(source='customer.name', read_only=True)
    invoice_number = serializers.CharField(source='invoice.invoice_number', read_only=True)
    order_number = serializers.CharField(source='order.order_number', read_only=True)
    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)

    class Meta:
        model = SalesCreditNote
        fields = [
            'id',
            'credit_note_number',
            'credit_note_type',
            'customer',
            'customer_name',
            'invoice',
            'invoice_number',
            'order',
            'order_number',
            'invoice_payment',
            'order_payment',
            'credit_note_date',
            'status',
            'amount',
            'reason',
            'detail_note',
            'description',
            'payout_method',
            'payout_account',
            'payout_voucher_number',
            'payout_cheque_number',
            'customer_bank_account_name',
            'customer_bank_name',
            'customer_bank_account_number',
            'journal_entry',
            'applied_to_invoice',
            'applied_at',
            'approved_by',
            'approved_by_name',
            'approved_at',
            'created_by',
            'created_by_name',
            'created_at',
            'updated_at',
        ]
        read_only_fields = [
            'credit_note_number',
            'status',
            'approved_by',
            'approved_at',
            'journal_entry',
            'created_by',
            'created_at',
            'updated_at',
        ]

    def validate(self, data):
        credit_note_type = data.get('credit_note_type', 'ar_credit')
        payout_method = data.get('payout_method')
        payout_account = data.get('payout_account')
        payout_voucher_number = data.get('payout_voucher_number')
        payout_cheque_number = data.get('payout_cheque_number')
        detail_note = data.get('detail_note')

        if not detail_note or not str(detail_note).strip():
            raise serializers.ValidationError({'detail_note': 'Detail note is required.'})

        if credit_note_type in ['payment_refund', 'payment_reverse']:
            if credit_note_type == 'payment_refund':
                if not payout_method:
                    raise serializers.ValidationError({'payout_method': 'Payout method is required for refunds.'})
                if not payout_account:
                    raise serializers.ValidationError({'payout_account': 'Payout account is required for refunds.'})
                if payout_method in ['cash', 'cheque'] and not payout_voucher_number:
                    raise serializers.ValidationError({'payout_voucher_number': 'Payout voucher number is required for cash/cheque refunds.'})
                if payout_method == 'cheque' and not payout_cheque_number:
                    raise serializers.ValidationError({'payout_cheque_number': 'Cheque number is required for cheque refunds.'})

        return data
        read_only_fields = [
            'status',
            'applied_to_invoice',
            'applied_at',
            'approved_by',
            'approved_by_name',
            'approved_at',
            'created_by',
            'created_at',
            'updated_at',
        ]

    def validate(self, data):
        """Validate payment method specific required fields."""
        payment_method = data.get('payment_method')

        # For bank_transfer and card: reference_number is required
        if payment_method in ['bank_transfer', 'card']:
            if not data.get('reference_number'):
                raise serializers.ValidationError({
                    'reference_number': f'{payment_method.replace("_", " ").title()} requires a reference number (e.g., transaction ID, auth code)'
                })

        # For cheque: cheque_number is required
        # cheque_deposit_account is optional (will default during clearance if not set)
        if payment_method == 'cheque':
            if not data.get('cheque_number'):
                raise serializers.ValidationError({
                    'cheque_number': 'Cheque number is required for cheque payments'
                })

        return data

class SalesInvoiceListSerializer(serializers.ModelSerializer):
    customer_name = serializers.CharField(source='customer.name', read_only=True)
    created_by_name = serializers.SerializerMethodField()
    invoice_type_display = serializers.CharField(source='get_invoice_type_display', read_only=True)

    class Meta:
        model = SalesInvoice
        fields = [
            'id', 'invoice_number', 'invoice_type', 'invoice_type_display',
            'customer', 'customer_name',
            'invoice_date', 'due_date', 'status', 'net_total',
            'amount_paid', 'balance_due', 'advances_applied', 'created_by_name'
        ]

    def get_created_by_name(self, obj):
        """Get prepared by name from prepared_by_legacy_id field (same approach as orders module)"""
        # Priority 1: Try to get from legacy ID (for migrated invoices)
        if obj.prepared_by_legacy_id:
            try:
                employee = Employee.objects.filter(legacy_id=obj.prepared_by_legacy_id).first()
                if employee:
                    # Return only the first name (same as orders module)
                    first_name = employee.full_name.split()[0] if employee.full_name else "Unknown"
                    return first_name
                return f"User {obj.prepared_by_legacy_id}"
            except Exception:
                return f"User {obj.prepared_by_legacy_id}"

        # Priority 2: Standard fields (for new invoices created in the new system)
        if obj.created_by:
            full_name = obj.created_by.get_full_name()
            return full_name.split()[0] if full_name else "Unknown"
        return "Unknown"

class SalesInvoiceDetailSerializer(serializers.ModelSerializer):
    customer_detail = CustomerSerializer(source='customer', read_only=True)
    order_detail = SalesOrderListSerializer(source='order', read_only=True)
    items = SalesInvoiceItemSerializer(many=True, read_only=True)
    payments = InvoicePaymentSerializer(many=True, read_only=True)
    credit_notes = SalesCreditNoteSerializer(many=True, read_only=True)
    timeline_entries = SalesInvoiceTimelineSerializer(many=True, read_only=True)
    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)

    class Meta:
        model = SalesInvoice
        fields = '__all__'

class SalesInvoiceCreateSerializer(serializers.ModelSerializer):
    items = SalesInvoiceItemSerializer(many=True, required=False)

    class Meta:
        model = SalesInvoice
        fields = '__all__'

    def create(self, validated_data):
        items_data = self.context.get('items', [])
        invoice = SalesInvoice.objects.create(**validated_data)
        
        for item_data in items_data:
            SalesInvoiceItem.objects.create(invoice=invoice, **item_data)
        
        return invoice
